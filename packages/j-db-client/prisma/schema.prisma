generator prisma_client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

generator nexusPrisma {
  provider = "nexus-prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Journaly Users.
model User {
  id                            Int                             @id @default(autoincrement())
  name                          String?
  email                         String                          @unique
  handle                        String                          @unique
  userRole                      UserRole                        @default(USER)
  bio                           String?
  createdAt                     DateTime                        @default(now())
  updatedAt                     DateTime                        @updatedAt
  profileImage                  String?
  city                          String?
  country                       String?
  stripeCustomerId              String?
  moosendSubscriberId           String?
  auth                          Auth?
  comments                      Comment[]
  commentThanks                 CommentThanks[]
  languagesLearning             LanguageLearning[]
  languagesNative               LanguageNative[]
  languages                     LanguageRelation[]
  membershipSubscription        MembershipSubscription?
  MembershipSubscriptionInvoice MembershipSubscriptionInvoice[]
  PendingNotification           PendingNotification[]
  posts                         Post[]
  savedPosts                    Post[]                          @relation("UserSavedPosts", references: [id])
  postComments                  PostComment[]
  postCommentSubscriptions      PostCommentSubscription[]
  postCommentThanks             PostCommentThanks[]
  postClaps                     PostClap[]
  socialMedia                   SocialMedia?
  threadSubscriptions           ThreadSubscription[]
  badges                        UserBadge[]
  userInterests                 UserInterest[]
  followedBy                    User[]                          @relation("UserFollows", references: [id])
  following                     User[]                          @relation("UserFollows", references: [id])
  lastFourCardNumbers           String?
  cardBrand                     String?
  notifications                 InAppNotification[]             @relation("notifications")
  notificationsTriggered        InAppNotification[]             @relation("notificationsTriggered")
  newFollowerNotifications      NewFollowerNotification[]

  isStudent Boolean @default(false)
}

/// Contains authentication-related data for each User.
model Auth {
  id                      Int                     @id @default(autoincrement())
  userId                  Int                     @unique
  password                String
  resetToken              String?
  resetTokenExpiry        Int?
  emailVerificationToken  String?
  emailVerificationStatus EmailVerificationStatus @default(PENDING)
  user                    User                    @relation(fields: [userId], references: [id])
}

/// Journaly Posts, which Users can create and publish on the platform.
model Post {
  id                       Int                       @id @default(autoincrement())
  title                    String
  body                     String
  bodySrc                  String                    @default("")
  excerpt                  String
  status                   PostStatus                @default(DRAFT)
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  authorId                 Int
  readTime                 Int                       @default(1)
  wordCount                Int                       @default(0)
  languageId               Int
  longitude                Decimal?
  latitude                 Decimal?
  publishedAt              DateTime?
  bumpedAt                 DateTime?
  bumpCount                Int                       @default(0)
  publishedLanguageLevel   LanguageLevel             @default(BEGINNER)
  author                   User                      @relation(fields: [authorId], references: [id])
  language                 Language                  @relation(fields: [languageId], references: [id])
  headlineImage            HeadlineImage             @relation(fields: [headlineImageId], references: [id])
  headlineImageId          Int                       @unique
  PendingNotification      PendingNotification[]
  postComments             PostComment[]
  postCommentSubscriptions PostCommentSubscription[]
  claps                    PostClap[]
  postTopics               PostTopic[]
  threads                  Thread[]
  notifications            InAppNotification[]
  savedUsers               User[]                    @relation("UserSavedPosts", references: [id])
  privateShareId           String?                   @unique
  newPostNotifications     NewPostNotification[]
}

/// Threads can contain many Comments that correspond to a conversation around some particular inline feedback in a Post.
model Thread {
  id                 Int                  @id @default(autoincrement())
  startIndex         Int
  endIndex           Int
  highlightedContent String
  postId             Int
  archived           Boolean              @default(false)
  post               Post                 @relation(fields: [postId], references: [id])
  comments           Comment[]
  subscriptions      ThreadSubscription[]
}

/// Represents inline feedback Comments specifically, those which appear inside of Threads within a Post.
model Comment {
  id                         Int                         @id @default(autoincrement())
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  body                       String
  authorId                   Int
  threadId                   Int
  author                     User                        @relation(fields: [authorId], references: [id])
  thread                     Thread                      @relation(fields: [threadId], references: [id])
  thanks                     CommentThanks[]
  PendingNotification        PendingNotification[]
  authorLanguageLevel        LanguageLevel               @default(BEGINNER)
  threadCommentNotifications ThreadCommentNotification[]
}

/// General Comments that are left underneath a Post and do not appear inside of Threads.
model PostComment {
  id                       Int                       @id @default(autoincrement())
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  body                     String
  authorId                 Int
  postId                   Int
  author                   User                      @relation(fields: [authorId], references: [id])
  post                     Post                      @relation(fields: [postId], references: [id])
  PendingNotification      PendingNotification[]
  thanks                   PostCommentThanks[]
  postCommentNotifications PostCommentNotification[]
  authorLanguageLevel      LanguageLevel             @default(BEGINNER)
}

/// Thanks that an inline feedback Comment receives from Users in the community.
model CommentThanks {
  id                              Int                               @id @default(autoincrement())
  createdAt                       DateTime                          @default(now())
  authorId                        Int
  commentId                       Int
  author                          User                              @relation(fields: [authorId], references: [id])
  comment                         Comment                           @relation(fields: [commentId], references: [id], onDelete: Cascade)
  PendingNotification             PendingNotification[]
  ThreadCommentThanksNotification ThreadCommentThanksNotification[]

  @@unique([authorId, commentId])
}

/// Thanks that a general PostComment receives from Users in the community.
model PostCommentThanks {
  id                  Int                   @id @default(autoincrement())
  createdAt           DateTime              @default(now())
  authorId            Int
  postCommentId       Int?
  author              User                  @relation(fields: [authorId], references: [id])
  PostComment         PostComment?          @relation(fields: [postCommentId], references: [id])
  PendingNotification PendingNotification[]

  @@unique([authorId, postCommentId])
}

/// Claps that a Post has received from Users in the community.
model PostClap {
  id                    Int                    @id @default(autoincrement())
  createdAt             DateTime               @default(now())
  postId                Int
  authorId              Int
  author                User                   @relation(fields: [authorId], references: [id])
  post                  Post                   @relation(fields: [postId], references: [id])
  PendingNotification   PendingNotification[]
  postClapNotifications PostClapNotification[]

  @@unique([authorId, postId])
}

/// Images that are used in the headline/title section of a Post, which also appear in any kind of Post feed (My Feed, My Posts, Profile)
model HeadlineImage {
  id        Int    @id @default(autoincrement())
  smallSize String
  largeSize String
  Post      Post[]
}

/// Represents A Many-To-Many Relationship between Languages and other models, such as Users LEARNING a Language.
model Language {
  id               Int                @id @default(autoincrement())
  name             String
  dialect          String?
  devName          String?
  learningUsers    LanguageLearning[]
  nativeUsers      LanguageNative[]
  LanguageRelation LanguageRelation[]
  posts            Post[]

  @@unique([name, dialect])
}

/// The intermediary table for our M2M relationship with Languages.
model LanguageRelation {
  id         Int           @id @default(autoincrement())
  userId     Int
  languageId Int
  createdAt  DateTime      @default(now())
  level      LanguageLevel
  language   Language      @relation(fields: [languageId], references: [id])
  user       User          @relation(fields: [userId], references: [id])

  @@unique([userId, languageId])
}

/// Each record represents a Language a User is learning.
model LanguageLearning {
  id         Int      @id @default(autoincrement())
  userId     Int
  languageId Int
  createdAt  DateTime @default(now())
  language   Language @relation(fields: [languageId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, languageId])
}

/// Each Record represents a Language a User speaks natively.
model LanguageNative {
  id         Int      @id @default(autoincrement())
  userId     Int
  languageId Int
  createdAt  DateTime @default(now())
  language   Language @relation(fields: [languageId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, languageId])
}

///  A core Topic which can have a M2M relationship with, for example, PostTopics or UserInterests.
model Topic {
  id                Int                @id @default(autoincrement())
  devName           String
  postTopics        PostTopic[]
  prompt            Prompt[]
  topicTranslations TopicTranslation[]
  userInterests     UserInterest[]
}

/// Topics a User is interested in.
model UserInterest {
  id        Int      @id @default(autoincrement())
  userId    Int
  topicId   Int
  createdAt DateTime @default(now())
  topic     Topic    @relation(fields: [topicId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, topicId])
}

/// Topics that a Post has been written about.
model PostTopic {
  id      Int   @id @default(autoincrement())
  postId  Int
  topicId Int
  post    Post  @relation(fields: [postId], references: [id])
  topic   Topic @relation(fields: [topicId], references: [id])

  @@unique([postId, topicId])
}

/// Translations of core Topics.
model TopicTranslation {
  id         Int        @id @default(autoincrement())
  uiLanguage UILanguage
  name       String
  topicId    Int
  topic      Topic      @relation(fields: [topicId], references: [id])

  @@unique([uiLanguage, topicId])
}

/// Writing Prompts that can be shown to Users to help them think of Topics to write about.
model Prompt {
  id      Int    @id @default(autoincrement())
  text    String
  topicId Int
  topic   Topic  @relation(fields: [topicId], references: [id])
}

/// Represents a subscription that any User has to a given Thread. Users are subscribed if they authored the post or left comments in that Thread.
model ThreadSubscription {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  userId    Int
  threadId  Int
  thread    Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, threadId])
}

/// Represents a subscription that any User has to PostComments in given Post. Users are subscribed if they authored the post or left any PostComments on it.
model PostCommentSubscription {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  userId    Int
  postId    Int
  post      Post     @relation(fields: [postId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, postId])
}

/// Represents a Journaly Premium Subscription.
model MembershipSubscription {
  id                   Int                          @id @default(autoincrement())
  period               MembershipSubscriptionPeriod
  userId               Int                          @unique
  stripeSubscription   Json
  stripeSubscriptionId String                       @unique
  expiresAt            DateTime?
  createdAt            DateTime                     @default(now())
  updatedAt            DateTime                     @updatedAt
  nextBillingDate      DateTime?
  cancelAtPeriodEnd    Boolean                      @default(false)
  lastPaymentFailure   Boolean                      @default(false)
  user                 User                         @relation(fields: [userId], references: [id])
}

/// Each record contains information from an individual Journaly Premium invoice, which would be created on every recurring MembershipSubscription payment.
model MembershipSubscriptionInvoice {
  id                                Int                                 @id @default(autoincrement())
  userId                            Int
  membershipSubscriptionPeriod      MembershipSubscriptionPeriod
  stripeInvoiceId                   String
  stripeInvoiceData                 Json
  createdAt                         DateTime                            @default(now())
  updatedAt                         DateTime                            @updatedAt
  user                              User                                @relation(fields: [userId], references: [id])
  MembershipSubscriptionInvoiceItem MembershipSubscriptionInvoiceItem[]
}

/// Each record contains individual items from a MembershipSubscriptionInvoice and corresponds heavily to Stripe's subscription datamodel.
model MembershipSubscriptionInvoiceItem {
  id                    Int                           @id @default(autoincrement())
  createdAt             DateTime                      @default(now())
  updatedAt             DateTime                      @updatedAt
  amount                Int
  currency              String
  description           String
  proration             Boolean
  invoiceId             Int
  stripeInvoiceItemId   String
  stripeInvoiceItemData Json
  invoice               MembershipSubscriptionInvoice @relation(fields: [invoiceId], references: [id])
}

/// Each record is a badge that a User has earned for a particular accomplishment, corresponding to a BadgeType.
model UserBadge {
  id        Int       @id @default(autoincrement())
  type      BadgeType
  createdAt DateTime  @default(now())
  userId    Int
  user      User      @relation(fields: [userId], references: [id])

  @@unique([userId, type])
}

/// Each record represents a single occurence on the platform that a User will be notified about in the Daily Digest Email. Table is cleared daily when the notifications are processed and emails are sent out.
model PendingNotification {
  id                  Int                   @id @default(autoincrement())
  type                EmailNotificationType
  createdAt           DateTime              @default(now())
  userId              Int
  postId              Int?
  postCommentThanksId Int?
  commentThanksId     Int?
  postCommentId       Int?
  commentId           Int?
  postClapId          Int?
  comment             Comment?              @relation(fields: [commentId], references: [id])
  commentThanks       CommentThanks?        @relation(fields: [commentThanksId], references: [id])
  postComment         PostComment?          @relation(fields: [postCommentId], references: [id])
  postCommentThanks   PostCommentThanks?    @relation(fields: [postCommentThanksId], references: [id])
  postClap            PostClap?             @relation(fields: [postClapId], references: [id])
  post                Post?                 @relation(fields: [postId], references: [id])
  user                User                  @relation(fields: [userId], references: [id])
}

/// Each record corresponds to a single, top-level In App Notification within the Notification Feed, which groups individual notifications together based on their InAppNotificationType.
model InAppNotification {
  id                               Int                               @id @default(autoincrement())
  type                             InAppNotificationType
  createdAt                        DateTime                          @default(now())
  bumpedAt                         DateTime?
  readStatus                       NotificationReadStatus            @default(UNREAD)
  postId                           Int?
  userId                           Int
  post                             Post?                             @relation(fields: [postId], references: [id])
  user                             User                              @relation(name: "notifications", fields: [userId], references: [id])
  triggeringUser                   User?                             @relation(name: "notificationsTriggered", fields: [triggeringUserId], references: [id])
  triggeringUserId                 Int?
  threadCommentNotifications       ThreadCommentNotification[]
  postCommentNotifications         PostCommentNotification[]
  newFollowerNotifications         NewFollowerNotification[]
  postClapNotifications            PostClapNotification[]
  threadCommentThanksNotifications ThreadCommentThanksNotification[]
  newPostNotifications             NewPostNotification[]
}

/// A single notification instance of a Comment within a Thread receiving CommentThanks from a User in the community.
model ThreadCommentThanksNotification {
  id Int @id @default(autoincrement())

  thanksId          Int
  notificationId    Int
  thanks            CommentThanks     @relation(fields: [thanksId], references: [id], onDelete: Cascade)
  notification InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
}

/// A single notification instance of an inline feedback Comment being left within a Thread that a User is subscribed to on a Post.
model ThreadCommentNotification {
  id             Int               @id @default(autoincrement())
  notificationId Int
  commentId      Int
  notification   InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  comment        Comment           @relation(fields: [commentId], references: [id], onDelete: Cascade)
}

/// A single notification instance of a PostComment being left on a Post that a User is subscribed to.
model PostCommentNotification {
  id             Int               @id @default(autoincrement())
  notificationId Int
  postCommentId  Int
  notification   InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  postComment    PostComment       @relation(fields: [postCommentId], references: [id], onDelete: Cascade)
}

/// A single notification a User receives when a new User follows them.
model NewFollowerNotification {
  id              Int               @id @default(autoincrement())
  notificationId  Int
  followingUserId Int
  notification    InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  followingUser   User              @relation(fields: [followingUserId], references: [id], onDelete: Cascade)
}

/// A single notification a User receives when a User claps for one of their Posts.
model PostClapNotification {
  id             Int               @id @default(autoincrement())
  notificationId Int
  postClapId     Int
  notification   InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  postClap       PostClap          @relation(fields: [postClapId], references: [id], onDelete: Cascade)
}

/// A single notification a User receives when another User they follow publishes a new Post.
model NewPostNotification {
  id             Int               @id @default(autoincrement())
  notificationId Int
  postId         Int
  notification   InAppNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  post           Post              @relation(fields: [postId], references: [id], onDelete: Cascade)
}

/// Contains social media information that each User can optionally include on their profile.
model SocialMedia {
  id        Int    @id @default(autoincrement())
  userId    Int    @unique
  website   String
  youtube   String
  instagram String
  facebook  String
  user      User   @relation(fields: [userId], references: [id])
}

/// The different levels to which a User may speak a language.
enum LanguageLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  NATIVE
}

/// The role of each User in the administrative hierarchy.
enum UserRole {
  ADMIN
  MODERATOR
  USER
}

/// The publishing status of a Post.
enum PostStatus {
  DRAFT
  PUBLISHED
  PRIVATE
}

/// The different Languages we support within the U.I.
enum UILanguage {
  ENGLISH
  GERMAN
  SPANISH
}

/// The various types of badges that Users can earn.
enum BadgeType {
  ALPHA_USER
  BETA_USER
  ONEHUNDRED_POSTS
  TEN_POSTS
  CODE_CONTRIBUTOR
  ODRADEK
  NECROMANCER
}

/// Each type of notification a User may receive within an email, such as the Daily Digest Email.
enum EmailNotificationType {
  THREAD_COMMENT
  POST_COMMENT
  THREAD_COMMENT_THANKS
  NEW_POST
  POST_CLAP
}

/// Each type of notification a User may receive within the In-App Notification Feed.
enum InAppNotificationType {
  THREAD_COMMENT
  POST_COMMENT
  THREAD_COMMENT_THANKS
  NEW_POST
  POST_CLAP
  NEW_FOLLOWER
}

/// The read/unread status of a notification a User may receive within the In-App Notification Feed.
enum NotificationReadStatus {
  READ
  UNREAD
}

/// The different Journaly Premium Membership recurring payment periods that we offer.
enum MembershipSubscriptionPeriod {
  MONTHLY
  QUARTERLY
  ANNUALY
  STUDENT_ANNUALLY
}

/// The status indicating whether or not a User has verified their email address.
enum EmailVerificationStatus {
  PENDING
  VERIFIED
}
